#' Ephemeral Collection Base
#'
#' @description Base class for ephemeral collections; ephemeral collections are
#' equivalent to \link[tiledbsoma:SOMACollection]{SOMA collections} but are
#' stored in-memory instead of on-disks
#'
#' @keywords internal
#' @export
#'
EphemeralCollectionBase <- R6::R6Class(
  classname = "EphemeralCollectionBase",
  inherit = SOMACollectionBase,
  public = list(
    # Override TileDBObject methods
    #' @description Create an ephemeral collection
    #'
    #' @template param-dots-ignored
    #'
    initialize = function(...) {
      # Check if any arguments were passed
      # If so, warn about unused arguments for ephemeral objects
      # Python equivalent:
      # def f(*args, **kwargs):
      #   if args or kwargs:
      #     warnings.warn("argumnets passed but unused")
      #   pass
      #
      if (rlang::dots_n(...)) {
        tryCatch(
          expr = private$.ephemeral_error("custom", "and cannot be customized"),
          error = function(e) {
            warning(conditionMessage(e), call. = FALSE, immediate. = TRUE)
          }
        )
      }
      private$.data <- list()
    },

    #' @description Create a new, empty ephemeral collection
    #'
    #' @return Returns a new ephemeral collection of class \code{class(self)}
    #'
    create = function() {
      gen <- getAnywhere(self$class())[["objs"]][[1L]]
      if (!R6::is.R6Class(gen)) {
        stop(
          "Cannot find the class generator for ",
          sQuote(self$class()),
          call. = FALSE
        )
      }
      return(gen$new())
    },

    # Override TileDBGroup private methods
    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param mode Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    open = function(mode) {
      private$.ephemeral_error("opened")
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @return Invisibly returns \code{NULL}
    #'
    close = function() {
      tryCatch(
        expr = private$.ephemeral_error("custom", "and cannot be closed"),
        error = function(e) {
          warning(conditionMessage(e), call. = FALSE, immediate. = TRUE)
        }
      )
      return(invisible(NULL))
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @return Returns \code{FALSE} as ephemeral collections do not
    #' exist on-disk
    #'
    exists = function() {
      return(FALSE)
    },

    # Override TileDBGroup methods
    #' @description Special method for printing object representation to console
    #'
    #' @return Prints details about the ephemeral collection and invisibly
    #' returns itself
    #'
    print = function() {
      super$print()
      private$format_members()
      return(invisible(self))
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param param Ignored for ephemeral objects
    #'
    #' @return Returns \code{NULL} as ephemeral collections do not have an
    #' on-disk configuration
    #'
    get_tiledb_config = function(param = NULL) {
      if (!is.null(param)) {
        tryCatch(
          expr = private$.ephemeral_error("custom", "and have no TileDB configuration"),
          error = function(e) {
            warning(conditionMessage(e), call. = FALSE, immediate. = TRUE)
          }
        )
      }
      return(NULL)
    },

    #' @description Retrieve the number of items in the collection
    #'
    #' @return The length of the collection
    length = function() {
      length(private$.data)
    },

    #' @description Retrieve the names of members. (lifecycle: maturing)
    #' @return A \code{character} vector of member names.
    names = function() {
      names(private$.data) %||% character(length = 0L)
    },

    #' @description Add object to an ephemeral collection
    #'
    #' @param object A TileDB object (eg. \code{\link{TileDBGroup}}) to add
    #' to the collection
    #' @param name A name to add \code{object} as
    #' @param relative Ignored for ephemeral objects
    #'
    #' @return \[chainable] Invisibly returns \code{self} with \code{object}
    #' added as \code{name}
    #'
    set = function(object, name = NULL, relative = NULL) {
      stopifnot(
        "Only 'TileDBArray' or 'TileDBGroup' objects can be added" =
          inherits(object, "TileDBGroup") || inherits(object, "TileDBArray"),
        is.null(name) || is_scalar_character(name),
        is.null(relative) || is_scalar_logical(relative)
      )
      if (!is.null(relative)) {
        tryCatch(
          expr = private$.ephemeral_error("custom", "so relative has no effect"),
          error = function(e) {
            warning(conditionMessage(e), call. = FALSE, immediate. = TRUE)
          }
        )
      }
      name <- name %||% object$uri
      private$.data[[name]] <- object
      return(invisible(self))
    },

    #' @description Get objects from an ephemeral collection
    #'
    #' @param name Name of object in the collection to get
    #'
    #' @return The object named \code{name}
    #'
    get = function(name) {
      stopifnot(is_scalar_character(name))
      name <- match.arg(arg = name, choices = self$names())
      return(private$.data[[name]])
    },

    #' @description Remove objects from an ephemeral collection
    #'
    #' @param name Name of object to remove from the collection
    #'
    #' @return \[chainable\] Invisibly returns \code{self} with the object at
    #' \code{name} removed
    remove = function(name) {
      stopifnot(is_scalar_character(name))
      name <- match.arg(arg = name, choices = self$names())
      private$.data[[name]] <- NULL
      return(invisible(self))
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param metadata Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    set_metadata = function(metadata) {
      private$.ephemeral_error("edited")
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param key Ignored for ephemeral objects
    #'
    #' @return An empty list
    #'
    get_metadata = function(key = NULL) {
      tryCatch(
        expr = private$.ephemeral_error("custom", "and have no metadata"),
        error = function(e) {
          warning(conditionMessage(e), call. = FALSE, immediate. = TRUE)
        }
      )
      return(list())
    },

    # Override SOMACollectionBase methods
    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param object,key Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    add_new_collection = function(object, key) {
      private$.ephemeral_error()
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param key,schema,index_column_names Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    add_new_dataframe = function(key, schema, index_column_names) {
      private$.ephemeral_error()
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param key,type,shape Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    add_new_dense_ndarray = function(key, type, shape) {
      private$.ephemeral_error()
    },

    #' @description Dummy method for ephemeral cobjects for compatibility with
    #' SOMA collections
    #'
    #' @param key,type,shape Ignored for ephemeral objects
    #'
    #' @return Throws an error as this method is not supported by ephemeral objects
    #'
    add_new_sparse_ndarray = function(key, type, shape) {
      private$.ephemeral_error()
    }
  ),
  active = list(

    #' @field uri \dQuote{\code{ephemeral-collection:<MEMORY_ADDRESS>}}
    uri = function(value) {
      if (!missing(value)) {
        private$.read_only_error("uri")
      }
      return(paste0("ephemeral-collection:", data.table::address(self)))
    },

    # Override SOMACollectionBase fields
    #' @field soma_type Dummy field for ephemeral objects for compatibility with
    #' SOMA collections
    soma_type = function(value) {
      if (!missing(value)) {
        private$.read_only_error("soma_type")
      }
      private$.ephemeral_error("custom", "and have no SOMA type")
    },

    # Override TileDBObject fields
    #' @field platform_config Dummy field for ephemeral objects for
    #' compatibility with SOMA collections
    platform_config = function(value) {
      if (!missing(value)) {
        private$.read_only_error("platform_config")
      }
      private$.ephemeral_error("custom", "and have no configuration")
    },

    #' @field tiledbsoma_ctx Dummy field for ephemeral objects for compatibility
    #' with SOMA collections
    tiledbsoma_ctx = function(value) {
      if (!missing(value)) {
        private$.read_only_error("tiledbsoma_ctx")
      }
      private$.ephemeral_error("custom", "and have no context")
    },

    #' @field object Dummy field for ephemeral objects for compatibility with
    #' SOMA collections
    object = function(value) {
      if (!missing(value)) {
        private$.read_only_error("object")
      }
      private$.ephemeral_error("custom", "and have no underlying object")
    }
  ),
  private = list(
    # Override SOMACollectionBase private fields
    tiledb_uri = NULL,
    tiledb_platform_config = NULL,
    .tiledbsoma_ctx = NULL,
    mode = NULL,

    # Override TileDBGroup private fields
    member_cache = NULL,
    check_open_for_read = function() { },
    check_open_for_write = function() { },
    check_open_for_read_or_write = function() { },
    fill_member_cache_if_null = function() { },
    update_member_cache = function() { },

    # Override SOMACollectionBase private fields
    soma_type_cache = NULL,
    initialize_object = function() {
      private$.ephemeral_error("custom", "and cannot be initialized")
    },
    get_all_members = function() {
      if (!length(private$.data)) {
        return(list())
      }
      members <- vector(mode = "list", length = length(private$.data))
      names(members) <- names(private$.data)
      for (i in seq_along(members)) {
        members[[i]] <- list(
          type = get_tiledb_object_type(
            private$.data[[i]]$uri,
            private$.soma_context
          ),
          uri = private$.data[[i]]$uri, name = names(private$.data)[i]
        )
      }
      return(members)
    },

    # Ephemeral fields
    .data = NULL,

    # Ephemeral methods
    .ephemeral_error = function(type = "added", msg = NULL) {
      stopifnot("'type' must be a single character value" = is_scalar_character(type))
      type <- match.arg(
        arg = type,
        choices = c(
          "base",
          "added",
          "opened",
          "edited",
          "custom"
        )
      )
      if (type == "custom" && !is_scalar_character(msg)) {
        stop("'msg' must be a single character value")
      }
      stop(
        sQuote(self$class()),
        " objects are ephemeral",
        switch(
          EXPR = type,
          added = " and cannot be added to",
          opened = " and cannot be opened",
          edited = " and cannot be edited",
          custom = paste0(" ", trimws(msg))
        ),
        call. = FALSE
      )
    }
  )
)

#' Ephemeral Collections
#'
#' @description Ephemeral version of \code{\link{SOMACollection}s}; ephemeral
#' collections are equivalent to
#' \link[tiledbsoma:SOMACollection]{SOMA collections} but are stored in-memory
#' instead of on-disk
#'
#' @keywords internal
#'
#' @export
#'
EphemeralCollection <- R6::R6Class(
  classname = "EphemeralCollection",
  inherit = EphemeralCollectionBase,
  active = list(
    #' @field soma_type The SOMA object type
    soma_type = function(value) {
      if (!missing(value)) {
        private$.read_only_error("soma_type")
      }
      return("SOMACollection")
    }
  )
)

#' Ephemeral SOMA Measurement
#'
#' @description Ephemeral version of \code{\link{SOMAMeasurement}s}; ephemeral
#' measurements are equivalent to
#' \link[tiledbsoma:SOMAMeasurement]{SOMA measurements} but are stored in-memory
#' instead of on-disk
#'
#' @keywords internal
#'
#' @export
#'
EphemeralMeasurement <- R6::R6Class(
  classname = "EphemeralMeasurement",
  inherit = EphemeralCollectionBase,
  active = list(
    #' @field var A \code{\link{SOMADataFrame}} containing primary annotations
    #' on the variable axis, for variables in this measurement (i.e., annotates
    #' columns of \code{X}). The contents of the \code{soma_joinid} column
    #' define the variable index domain, \code{var_id}. All variables for this
    #' measurement must be defined in this data frame
    var = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "var",
        expected_class = "SOMADataFrame"
      )
    },

    #' @field X A \code{\link{SOMACollection}} of
    #' \code{\link{SOMASparseNDArray}}s; each contain measured feature values
    #' indexed by \code{[obsid, varid]}
    X = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "X",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field obsm A \code{\link{SOMACollection}} of
    #' \code{\link{SOMADenseNDArray}}s containing annotations on the observation
    #' axis. Each array is indexed by \code{obsid} and has the same shape as
    #' \code{obs}
    obsm = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "obsm",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field obsp A \code{\link{SOMACollection}} of
    #' \code{\link{SOMASparseNDArray}}s containing pairwise annotations on the
    #' observation axis and indexed with \code{[obsid_1, obsid_2]}
    obsp = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "obsp",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field varm A \code{\link{SOMACollection}} of
    #' \code{\link{SOMADenseNDArray}}s containing annotations on the variable
    #' axis. Each array is indexed by \code{varid} and has the same shape as
    #' \code{var}
    varm = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "varm",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field varp A \code{\link{SOMACollection}} of
    #' \code{\link{SOMASparseNDArray}}s containing pairwise annotations on the
    #' variable axis and indexed with \code{[varid_1, varid_2]}
    varp = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "varp",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field soma_type The SOMA object type
    soma_type = function(value) {
      if (!missing(value)) {
        private$.read_only_error("soma_type")
      }
      return("SOMAMeasurement")
    }
  )
)

#' Ephemeral SOMA Experiment
#'
#' @description Ephemeral version of \code{\link{SOMAExperiment}s}; ephemeral
#' experiments are equivalent to
#' \link[tiledbsoma:SOMAExperiment]{SOMA experiments} but are stored in-memory
#' instead of on-disk
#'
#' @keywords internal
#'
#' @export
#'
EphemeralExperiment <- R6::R6Class(
  classname = "EphemeralExperiment",
  inherit = EphemeralCollectionBase,
  active = list(
    #' @field obs A \code{\link{SOMADataFrame}} containing the annotations on
    #' the observation axis. The contents of the \code{soma_joinid} column
    #' define the observation index domain \code{obs_id}. All observations for
    #' the \code{SOMAExperiment} must be defined in this data frame
    obs = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "obs",
        expected_class = "SOMADataFrame"
      )
    },

    #' @field ms A \code{\link{SOMACollection}} of named
    #' \code{\link{SOMAMeasurement}}s
    ms = function(value) {
      private$get_or_set_soma_field(
        value = value,
        name = "ms",
        expected_class = c("EphemeralCollection", "SOMACollection")
      )
    },

    #' @field soma_type The SOMA object type
    soma_type = function(value) {
      if (!missing(value)) {
        private$.read_only_error("soma_type")
      }
      return("SOMAExperiment")
    }
  )
)
