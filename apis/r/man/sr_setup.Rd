% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{sr_setup}
\alias{sr_setup}
\alias{sr_complete}
\alias{sr_next}
\title{Iterator-Style Access to SOMA Array via SOMAReader}
\usage{
sr_setup(ctx, uri, loglevel = "warn")

sr_complete(sr)

sr_next(sr)
}
\arguments{
\item{ctx}{An external pointer to a TileDB Context object}

\item{uri}{Character value with URI path to a SOMA data set}

\item{loglevel}{Character value with the desired logging level, defaults to \sQuote{warn}}

\item{sr}{An external pointer to a TileDB SOMAReader object}
}
\value{
\code{sr_setup} returns an external pointer to a SOMAReader. \code{sr_complete}
returns a boolean, and \code{sr_next} returns an Arrow array helper object.
}
\description{
The \verb{sr_*} functions provide low-level access to an instance of the SOMAReader
class so that iterative access over parts of a (large) array is possible.
\describe{
\item{\code{sr_setup}}{instantiates and by default also submits a query}
\item{\code{sr_complete}}{checks if more data is available}
\item{\code{sr_next}}{returns the next chunk}
}
}
\examples{
\dontrun{
ctx <- tiledb_ctx()
sr <- sr_setup(ctx@ptr, uri, "warn")
rl <- data.frame()
while (nrow(rl) == 0 || !tiledbsoma:::sr_complete(sr)) {
    dat <- tiledbsoma:::sr_next(sr)
    dat |>
        arch::from_arch_array(arrow::RecordBatch) |>
        arrow::as_arrow_table() |>
        collect() |>
        as.data.frame() |>
        data.table() -> D
    rl <- rbind(rl, D)
}
summary(rl)
}
}
